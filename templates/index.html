{% extends "base.html" %}
{% block content %}
<div class="container mt-5">
    <h2 class="mb-4">K-Means Clustering Tool with Interactive Editing</h2>

    <!-- File Upload -->
    <div class="card p-3 mb-3">
        <h5>Upload CSV</h5>
        <form id="uploadForm">
            <input type="file" id="fileInput" accept=".csv" class="form-control mb-2" required>
            <button type="submit" class="btn btn-primary">Upload</button>
        </form>
        <div id="uploadMsg" class="mt-2 text-success"></div>
    </div>

    <!-- Column Selection -->
    <div class="card p-3 mb-3" id="columnCard" style="display:none;">
        <h5>Select Columns</h5>
        <label>X Column:</label>
        <select id="xColumn" class="form-select mb-2"></select>
        <label>Y Column:</label>
        <select id="yColumn" class="form-select mb-2"></select>
        <label>K (1‚Äì10):</label>
        <input type="number" id="kValue" class="form-control mb-2" value="3" min="1" max="10">
        <label>Initialization:</label>
        <select id="initMethod" class="form-select mb-2">
            <option value="random">Random</option>
            <option value="kmeans++">K-means++</option>
        </select>
        <button class="btn btn-success" onclick="runClustering()">Run Clustering</button>
    </div>

    <!-- Results -->
    <div id="resultsCard" class="card p-3 mb-3" style="display:none;">
        <h5>Results</h5>
        <div class="row">
            <div class="col-md-6">
                <p><strong>Centroids:</strong></p>
                <pre id="centroids"></pre>
            </div>
            <div class="col-md-6">
                <p><strong>SSE:</strong> <span id="sse"></span></p>
                <p><strong>Number of Clusters:</strong> <span id="currentK"></span></p>
            </div>
        </div>

        <!-- Cluster Editing Controls -->
        <div class="card p-3 mb-3" id="editingControls" style="display:none;">
            <h6>üéØ Interactive Cluster Editing</h6>
            
            <!-- Edit Mode Toggle -->
            <div class="mb-3">
                <button id="editModeBtn" class="btn btn-warning" onclick="toggleEditMode()">Enter Edit Mode</button>
                <span id="editModeStatus" class="ms-2"></span>
            </div>

            <!-- Point Editing -->
            <div id="pointEditingSection" style="display:none;">
                <div class="row mb-3">
                    <div class="col-md-12">
                        <label class="form-label"><strong>Select Target Cluster:</strong></label>
                        <div id="clusterButtons" class="d-flex flex-wrap gap-2 mt-2"></div>
                    </div>
                </div>

                <!-- Action Buttons -->
                <div class="row mb-3">
                    <div class="col-md-12">
                        <h6>Advanced Operations:</h6>
                        <button class="btn btn-info btn-sm me-2" onclick="showMergeDialog()">Merge Clusters</button>
                        <button class="btn btn-success btn-sm me-2" onclick="showSplitDialog()">Split Cluster</button>
                        <button class="btn btn-secondary btn-sm me-2" onclick="undoLastEdit()">‚Ü∂ Undo</button>
                        <button class="btn btn-outline-danger btn-sm" onclick="resetAllEdits()">Reset All Edits</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Animation Controls -->
        <div class="mb-3">
            <h6>Animation Controls</h6>
            <button id="playBtn" class="btn btn-primary me-2" onclick="playAnimation()">Play Animation</button>
            <button id="pauseBtn" class="btn btn-warning me-2" onclick="pauseAnimation()" disabled>Pause</button>
            <button id="resetBtn" class="btn btn-secondary me-2" onclick="resetAnimation()">Reset</button>
            <label class="me-2">Speed:</label>
            <input type="range" id="speedControl" min="500" max="3000" value="1500" class="form-range" style="width:150px; display:inline-block;">
            <span class="ms-2">Step: <span id="currentStep">0</span> / <span id="totalSteps">0</span></span>
        </div>

        <div class="row">
            <div class="col-md-6">
                <h6>Cluster Plot</h6>
                <canvas id="clusterPlot" style="cursor: default;"></canvas>
            </div>
            <div class="col-md-6">
                <h6>Elbow Method</h6>
                <canvas id="elbowPlot"></canvas>
            </div>
        </div>
    </div>
</div>

<!-- Merge Dialog Modal -->
<div class="modal fade" id="mergeModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Merge Clusters</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <label>Merge Cluster:</label>
                <select id="mergeCluster1" class="form-select mb-2"></select>
                <label>Into Cluster:</label>
                <select id="mergeCluster2" class="form-select mb-2"></select>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" onclick="executeMerge()">Merge</button>
            </div>
        </div>
    </div>
</div>

<!-- Split Dialog Modal -->
<div class="modal fade" id="splitModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Split Cluster</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <label>Select Cluster to Split:</label>
                <select id="splitCluster" class="form-select mb-2"></select>
                <small class="text-muted">The selected cluster will be split into two clusters using k-means.</small>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-success" onclick="executeSplit()">Split</button>
            </div>
        </div>
    </div>
</div>

<!-- Bootstrap JS -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
<!-- Chart.js -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
let clusterChart, elbowChart;
let animationHistory = [];
let currentAnimationStep = 0;
let animationTimer = null;
let isAnimating = false;

// Edit mode variables
let editMode = false;
let selectedTargetCluster = 0;
let currentK = 3;
let plotData = null;

// Colors for clusters
const clusterColors = ["red","blue","green","purple","orange","brown","pink","cyan","magenta","yellow"];

document.getElementById("uploadForm").addEventListener("submit", async (e) => {
    e.preventDefault();
    let file = document.getElementById("fileInput").files[0];
    if (!file) return;

    let formData = new FormData();
    formData.append("file", file);

    let res = await fetch("/upload", { method: "POST", body: formData });
    let data = await res.json();

    if (res.ok) {
        document.getElementById("uploadMsg").innerText = data.message;
        let xSel = document.getElementById("xColumn");
        let ySel = document.getElementById("yColumn");
        xSel.innerHTML = ""; ySel.innerHTML = "";
        data.columns.forEach(col => {
            xSel.innerHTML += `<option value="${col}">${col}</option>`;
            ySel.innerHTML += `<option value="${col}">${col}</option>`;
        });
        document.getElementById("columnCard").style.display = "block";
        // Hide results if previously shown
        document.getElementById("resultsCard").style.display = "none";
    } else {
        alert(data.error);
    }
});

async function runClustering() {
    let x = document.getElementById("xColumn").value;
    let y = document.getElementById("yColumn").value;
    let k = parseInt(document.getElementById("kValue").value);
    let init = document.getElementById("initMethod").value;

    let res = await fetch("/cluster", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ x_column: x, y_column: y, k: k, init: init })
    });
    let data = await res.json();

    if (res.ok) {
        document.getElementById("centroids").innerText = JSON.stringify(data.centroids, null, 2);
        document.getElementById("sse").innerText = data.sse.toFixed(2);
        currentK = k;
        document.getElementById("currentK").innerText = currentK;

        // Store animation history
        animationHistory = data.history;
        document.getElementById("totalSteps").innerText = animationHistory.length;
        document.getElementById("currentStep").innerText = "0";
        currentAnimationStep = 0;

        // Reset edit mode
        editMode = false;
        updateEditModeUI();

        // Now fetch plots
        await refreshPlots();
        
        document.getElementById("resultsCard").style.display = "block";
        document.getElementById("editingControls").style.display = "block";
    } else {
        alert(data.error);
    }
}

async function refreshPlots() {
    let plotRes = await fetch("/plots");
    let data = await plotRes.json();
    if (plotRes.ok) {
        plotData = data;
        currentK = data.k || currentK;
        document.getElementById("currentK").innerText = currentK;
        showClusterPlot(data.points, data.centroids);
        showElbowPlot(data.elbow.k_values, data.elbow.sse_values);
        updateClusterButtons();
    }
}

function showClusterPlot(points, centroids) {
    let ctx = document.getElementById("clusterPlot").getContext("2d");
    if (clusterChart) clusterChart.destroy();
    
    let datasets = [];
    let grouped = {};
    
    // Group points by cluster
    points.forEach(p => {
        if (!grouped[p.cluster]) grouped[p.cluster] = [];
        grouped[p.cluster].push({x: p.x, y: p.y});
    });
    
    // Create datasets for each cluster
    Object.keys(grouped).forEach(c => {
        datasets.push({ 
            label: "Cluster " + c, 
            data: grouped[c], 
            pointRadius: editMode ? 8 : 5,
            pointHoverRadius: editMode ? 10 : 7,
            backgroundColor: clusterColors[c % clusterColors.length],
            pointBorderWidth: editMode ? 2 : 0,
            pointBorderColor: editMode ? '#000' : 'transparent'
        });
    });
    
    // Add centroids
    datasets.push({ 
        label: "Centroids", 
        data: centroids.map(c => ({x: c[0], y: c[1]})), 
        pointRadius: 8, 
        backgroundColor: "black",
        borderColor: "white",
        borderWidth: 2,
        showLine: false
    });
    
    clusterChart = new Chart(ctx, { 
        type: "scatter", 
        data: { datasets },
        options: {
            onClick: editMode ? handleChartClick : null,
            plugins: {
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            if (context.datasetIndex === datasets.length - 1) {
                                return `Centroid ${context.dataIndex}: (${context.parsed.x.toFixed(2)}, ${context.parsed.y.toFixed(2)})`;
                            } else {
                                return `Point (${context.parsed.x.toFixed(2)}, ${context.parsed.y.toFixed(2)}) - Cluster ${context.datasetIndex}`;
                            }
                        }
                    }
                }
            },
            scales: {
                x: {
                    type: 'linear',
                    position: 'bottom'
                }
            }
        }
    });
    
    // Update cursor style
    document.getElementById("clusterPlot").style.cursor = editMode ? "crosshair" : "default";
}

function showElbowPlot(kVals, sseVals) {
    let ctx = document.getElementById("elbowPlot").getContext("2d");
    if (elbowChart) elbowChart.destroy();
    elbowChart = new Chart(ctx, {
        type: "line",
        data: {
            labels: kVals,
            datasets: [{ label: "SSE", data: sseVals, borderColor: "blue", fill: false }]
        },
        options: {
            scales: {
                x: {
                    title: {
                        display: true,
                        text: 'Number of Clusters (k)'
                    }
                },
                y: {
                    title: {
                        display: true,
                        text: 'Sum of Squared Errors'
                    }
                }
            }
        }
    });
}

// Edit Mode Functions
function toggleEditMode() {
    editMode = !editMode;
    updateEditModeUI();
    if (plotData) {
        showClusterPlot(plotData.points, plotData.centroids);
    }
}

function updateEditModeUI() {
    const editBtn = document.getElementById("editModeBtn");
    const editStatus = document.getElementById("editModeStatus");
    const pointEditSection = document.getElementById("pointEditingSection");
    
    if (editMode) {
        editBtn.textContent = "Exit Edit Mode";
        editBtn.className = "btn btn-success";
        editStatus.innerHTML = '<span class="badge bg-warning text-dark">‚úèÔ∏è Edit Mode Active</span>';
        pointEditSection.style.display = "block";
        updateClusterButtons();
    } else {
        editBtn.textContent = "Enter Edit Mode";
        editBtn.className = "btn btn-warning";
        editStatus.innerHTML = '<span class="badge bg-secondary">üëÅÔ∏è View Mode</span>';
        pointEditSection.style.display = "none";
    }
}

function updateClusterButtons() {
    const buttonContainer = document.getElementById("clusterButtons");
    buttonContainer.innerHTML = "";
    
    // Get unique clusters from current data
    let uniqueClusters = new Set();
    if (plotData && plotData.points) {
        plotData.points.forEach(p => uniqueClusters.add(p.cluster));
    }
    
    uniqueClusters = Array.from(uniqueClusters).sort((a, b) => a - b);
    
    uniqueClusters.forEach(clusterId => {
        const btn = document.createElement("button");
        btn.className = `btn btn-outline-primary btn-sm me-1 mb-1 ${selectedTargetCluster === clusterId ? 'active' : ''}`;
        btn.style.backgroundColor = selectedTargetCluster === clusterId ? clusterColors[clusterId % clusterColors.length] : 'transparent';
        btn.style.borderColor = clusterColors[clusterId % clusterColors.length];
        btn.style.color = selectedTargetCluster === clusterId ? 'white' : clusterColors[clusterId % clusterColors.length];
        btn.textContent = `Cluster ${clusterId}`;
        btn.onclick = () => selectTargetCluster(clusterId);
        buttonContainer.appendChild(btn);
    });
}

function selectTargetCluster(clusterId) {
    selectedTargetCluster = clusterId;
    updateClusterButtons();
}

async function handleChartClick(event, elements) {
    if (!editMode || elements.length === 0) return;
    
    const element = elements[0];
    const datasetIndex = element.datasetIndex;
    
    // Don't edit centroids (last dataset)
    if (datasetIndex === clusterChart.data.datasets.length - 1) return;
    
    // Find the actual point index in our data
    const pointInCluster = element.index;
    let actualPointIndex = 0;
    let currentCluster = 0;
    
    // Count points until we reach the clicked point
    for (let i = 0; i < plotData.points.length; i++) {
        if (plotData.points[i].cluster === datasetIndex) {
            if (currentCluster === pointInCluster) {
                actualPointIndex = i;
                break;
            }
            currentCluster++;
        }
    }
    
    // Edit the point
    await editPoint(actualPointIndex, selectedTargetCluster);
}

async function editPoint(pointIndex, newCluster) {
    try {
        const response = await fetch("/edit-point", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                point_index: pointIndex,
                new_cluster: newCluster
            })
        });
        
        const data = await response.json();
        
        if (data.success) {
            // Update display
            document.getElementById("centroids").innerText = JSON.stringify(data.centroids, null, 2);
            document.getElementById("sse").innerText = data.sse.toFixed(2);
            
            // Refresh plots
            await refreshPlots();
        } else {
            alert(data.error || "Failed to edit point");
        }
    } catch (error) {
        alert("Error editing point: " + error.message);
    }
}

// Merge Functions
function showMergeDialog() {
    const modal = new bootstrap.Modal(document.getElementById('mergeModal'));
    const cluster1Select = document.getElementById('mergeCluster1');
    const cluster2Select = document.getElementById('mergeCluster2');
    
    // Populate cluster options
    cluster1Select.innerHTML = "";
    cluster2Select.innerHTML = "";
    
    let uniqueClusters = new Set();
    if (plotData && plotData.points) {
        plotData.points.forEach(p => uniqueClusters.add(p.cluster));
    }
    
    Array.from(uniqueClusters).sort((a, b) => a - b).forEach(clusterId => {
        cluster1Select.innerHTML += `<option value="${clusterId}">Cluster ${clusterId}</option>`;
        cluster2Select.innerHTML += `<option value="${clusterId}">Cluster ${clusterId}</option>`;
    });
    
    modal.show();
}

async function executeMerge() {
    const cluster1 = parseInt(document.getElementById('mergeCluster1').value);
    const cluster2 = parseInt(document.getElementById('mergeCluster2').value);
    
    if (cluster1 === cluster2) {
        alert("Cannot merge a cluster with itself!");
        return;
    }
    
    try {
        const response = await fetch("/merge-clusters", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                cluster1: cluster1,
                cluster2: cluster2
            })
        });
        
        const data = await response.json();
        
        if (data.success) {
            // Update display
            document.getElementById("centroids").innerText = JSON.stringify(data.centroids, null, 2);
            document.getElementById("sse").innerText = data.sse.toFixed(2);
            
            // Refresh plots
            await refreshPlots();
            
            // Close modal
            bootstrap.Modal.getInstance(document.getElementById('mergeModal')).hide();
        } else {
            alert(data.error || "Failed to merge clusters");
        }
    } catch (error) {
        alert("Error merging clusters: " + error.message);
    }
}

// Split Functions
function showSplitDialog() {
    const modal = new bootstrap.Modal(document.getElementById('splitModal'));
    const splitSelect = document.getElementById('splitCluster');
    
    // Populate cluster options
    splitSelect.innerHTML = "";
    
    let uniqueClusters = new Set();
    if (plotData && plotData.points) {
        plotData.points.forEach(p => uniqueClusters.add(p.cluster));
    }
    
    Array.from(uniqueClusters).sort((a, b) => a - b).forEach(clusterId => {
        splitSelect.innerHTML += `<option value="${clusterId}">Cluster ${clusterId}</option>`;
    });
    
    modal.show();
}

async function executeSplit() {
    const clusterToSplit = parseInt(document.getElementById('splitCluster').value);
    
    try {
        const response = await fetch("/split-cluster", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                cluster_to_split: clusterToSplit
            })
        });
        
        const data = await response.json();
        
        if (data.success) {
            // Update display
            document.getElementById("centroids").innerText = JSON.stringify(data.centroids, null, 2);
            document.getElementById("sse").innerText = data.sse.toFixed(2);
            currentK = data.new_k;
            document.getElementById("currentK").innerText = currentK;
            
            // Refresh plots
            await refreshPlots();
            
            // Close modal
            bootstrap.Modal.getInstance(document.getElementById('splitModal')).hide();
        } else {
            alert(data.error || "Failed to split cluster");
        }
    } catch (error) {
        alert("Error splitting cluster: " + error.message);
    }
}

// Undo Function
async function undoLastEdit() {
    try {
        const response = await fetch("/undo-edit", {
            method: "POST",
            headers: { "Content-Type": "application/json" }
        });
        
        const data = await response.json();
        
        if (data.success) {
            // Update display
            document.getElementById("centroids").innerText = JSON.stringify(data.centroids, null, 2);
            document.getElementById("sse").innerText = data.sse.toFixed(2);
            if (data.k) {
                currentK = data.k;
                document.getElementById("currentK").innerText = currentK;
            }
            
            // Refresh plots
            await refreshPlots();
            
            // Show feedback
            const status = document.getElementById("editModeStatus");
            const originalHTML = status.innerHTML;
            status.innerHTML = '<span class="badge bg-info">‚Ü∂ Undone: ' + data.undone_action + '</span>';
            setTimeout(() => {
                status.innerHTML = originalHTML;
            }, 2000);
        } else {
            alert(data.error || "Nothing to undo");
        }
    } catch (error) {
        alert("Error undoing edit: " + error.message);
    }
}

// Reset Function
async function resetAllEdits() {
    if (!confirm("Are you sure you want to reset all manual edits?")) return;
    
    try {
        const response = await fetch("/reset-edits", {
            method: "POST",
            headers: { "Content-Type": "application/json" }
        });
        
        const data = await response.json();
        
        if (data.success) {
            // Update display
            document.getElementById("centroids").innerText = JSON.stringify(data.centroids, null, 2);
            document.getElementById("sse").innerText = data.sse.toFixed(2);
            
            // Refresh plots
            await refreshPlots();
            
            // Show feedback
            const status = document.getElementById("editModeStatus");
            const originalHTML = status.innerHTML;
            status.innerHTML = '<span class="badge bg-success">üîÑ All edits reset</span>';
            setTimeout(() => {
                status.innerHTML = originalHTML;
            }, 2000);
        } else {
            alert(data.error || "Failed to reset edits");
        }
    } catch (error) {
        alert("Error resetting edits: " + error.message);
    }
}

// Animation functions (keeping original functionality)
function playAnimation() {
    if (animationHistory.length === 0) return;
    
    isAnimating = true;
    document.getElementById("playBtn").disabled = true;
    document.getElementById("pauseBtn").disabled = false;
    
    animationTimer = setInterval(() => {
        showAnimationStep(currentAnimationStep);
        currentAnimationStep++;
        
        if (currentAnimationStep >= animationHistory.length) {
            pauseAnimation();
            currentAnimationStep = animationHistory.length - 1;
        }
    }, 3500 - parseInt(document.getElementById("speedControl").value));
}

function pauseAnimation() {
    isAnimating = false;
    if (animationTimer) {
        clearInterval(animationTimer);
        animationTimer = null;
    }
    document.getElementById("playBtn").disabled = false;
    document.getElementById("pauseBtn").disabled = true;
}

function resetAnimation() {
    pauseAnimation();
    currentAnimationStep = 0;
    document.getElementById("currentStep").innerText = "0";
    if (animationHistory.length > 0) {
        showAnimationStep(0);
    }
}

function showAnimationStep(step) {
    if (step >= animationHistory.length || step < 0) return;
    
    document.getElementById("currentStep").innerText = step + 1;
    
    let historyStep = animationHistory[step];
    let centroids = historyStep.centroids;
    let labels = historyStep.labels;
    
    // Get original data points from the last clustering result
    fetch("/plots").then(res => res.json()).then(plotData => {
        if (plotData.points) {
            // Create animated plot data
            let animatedPoints = plotData.points.map((point, i) => ({
                x: point.x,
                y: point.y,
                cluster: labels.length > i ? labels[i] : 0
            }));
            
            showAnimatedClusterPlot(animatedPoints, centroids, step);
        }
    });
}

function showAnimatedClusterPlot(points, centroids, step) {
    let ctx = document.getElementById("clusterPlot").getContext("2d");
    if (clusterChart) clusterChart.destroy();
    
    let datasets = [];
    let grouped = {};
    
    points.forEach(p => {
        if (!grouped[p.cluster]) grouped[p.cluster] = [];
        grouped[p.cluster].push({x: p.x, y: p.y});
    });
    
    Object.keys(grouped).forEach(c => {
        datasets.push({ 
            label: "Cluster " + c, 
            data: grouped[c], 
            pointRadius: 5, 
            backgroundColor: clusterColors[c % clusterColors.length],
            showLine: false
        });
    });
    
    // Add centroids with different styling for animation
    datasets.push({ 
        label: "Centroids", 
        data: centroids.map(c => ({x: c[0], y: c[1]})), 
        pointRadius: step === 0 ? 10 : 8,
        backgroundColor: step === 0 ? "orange" : "black",
        borderColor: "white",
        borderWidth: 2,
        showLine: false
    });
    
    clusterChart = new Chart(ctx, { 
        type: "scatter", 
        data: { datasets },
        options: {
            plugins: {
                title: {
                    display: true,
                    text: step === 0 ? "Initial Centroids" : `Iteration ${step}`
                }
            }
        }
    });
}
</script>
{% endblock %}